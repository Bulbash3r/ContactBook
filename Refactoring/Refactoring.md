### Содержание
1. [Предпосылки использования паттерна проектирования](#1)
2. [Паттерн проектирования "Наблюдатель"](#2)
3. [Реализация шаблона в проекте](#3)
4. [Заключение](#4)


<a name="1"></a>
### 1. Предпосылки использования паттерна проектирования

Проект, разрабатываемый в течении семестра, должен был поддерживать русскую и английскую локализацию и в ходе разработки я столкнулся с одной проблемой: при смене языка приложения по нажатию на кнопку в главное окне приложения, язык должен измениться во всех окнах. Изучив лекционный материал и материалы ресурса refactoring.guru, я нашёл решение проблемы.

<a name="2"></a>
### 2. Паттерн проектирования "Наблюдатель"

Наблюдатель (англ. Observer) - это поведенческий паттерн проектирования, который создаёт механизм "подписки", который позволяет одним объектам следить и реагировать на события, происходящие в других объектах, уведомлять и обновлять все зависящие объекты.
Он используется в следующих случаях:
|1|Существует, как минимум, один объект, рассылающий сообщения|
|2|Имеется не менее одного получателя сообщений причём их количество и состав могут изменяться во время работы приложения|
|3|Нет надобности очень сильно связывать взаимодействующие объекты, в которых отправителя сообщений не интересует, что делают получатели с предоставленной им информацией|
 
<a name="3"></a>
### 3. Реализация шаблона в проекте

При реализации шаблона "Observer" в проекте я использовал следующие классы:
1. `java.util.Observable` - интерфейс, определяющий методы для добавления, удаления и оповещения наблюдателей
2. `java.util.Observer` - интерфейс, с помощью которого наблюдатель получает оповещение
3. `controlles.MainController` - класс, который реализует интерфейс Observable
4. `start.Main` - класс, который реализует интерфейс Observer

Ниже представлена часть диаграммы классов проекта, отображающая работу шаблона.

![Диграмма классов](https://github.com/Bulbash3r/ContactBook/blob/master/Refactoring/Diagram.png?raw=true)  
Рассмотрим подробнее код программы 

`MainController.java`
```java
private void initListeners() {

        //...инициализация других слушателей
        //инициализаия слушателя изменения языка
        comboLocales.setOnAction(new EventHandler<ActionEvent>() {
            @Override
            public void handle(ActionEvent event) {
		//Установка выбраного языка в менеджере языков
                Lang selectedLang = (Lang) comboLocales.getSelectionModel().getSelectedItem();
                LocaleManager.setCurrentLang(selectedLang);

                //Уведомляем слушателей, что произошла смена языка
                setChanged();	//меняем флаг изменения на true
                notifyObservers(selectedLang); //уведомляет слушателей о смене, флаг изменения в false
            }
        });
}
```

Класс `Main.java` реализует унаследованный от интерфейса `Observer метод update(Observable, Object)`:

```Java
    @Override
    public void update(Observable o, Object arg) {
        Lang lang = (Lang) arg; //Получаем язык, переданный в метод notifyObservers
        VBox newNode = loadFXML(lang.getLocale()); //Получаем новое дерево компонетов с нужным языком
        currentRoot.getChildren().setAll(newNode.getChildren()); //Заменяем старые данные компонента на новые - с другим языком

    }

//метод загрузки дерева компонентов (один из инициализирующих методов)
     private VBox loadFXML(Locale locale) {
     fxmlLoader = new FXMLLoader();

     fxmlLoader.setLocation(getClass().getResource(FXML_MAIN));
     fxmlLoader.setResources(ResourceBundle.getBundle(BUNDLES_FOLDER, locale));

     VBox node = null;

     try {
         node = (VBox) fxmlLoader.load();
	 //Получаем контроллер и добавляем к нему наблюдателя
         mainController = fxmlLoader.getController();
         mainController.addObserver(this);
         primaryStage.setTitle(fxmlLoader.getResources().getString("address_book"));

     } catch (IOException e) {
         e.printStackTrace();
     }

     return node;
 }
```

<a name="4"></a>
### 4. Заключение

Как и другие паттерны проектирования, шаблон "Наблюдатель" - выверенное многолетним опытом программистов решение, когда требуется определить зависимость "Один-ко-многим" между объектами так, чтобы при изменении состояния одного объекта все зависящие от него объекты уведомлялись и автоматически обновлялись.
Шаблон "Observer" отлично вписывается в используемую в проекте модель Model-View-Controller в качестве части View. Использование шаблона позволило значительно уменьшить количество кода и затраченного времени.